package your.package.here; // <- change this to the package of your tests

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest; // change to jakarta.servlet.http.HttpServletRequest if your project uses Jakarta
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.MockedConstruction;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.ResponseEntity;

import com.cox.oss.prov.pal.common.proxy.restapi.PalCmiProxyRestController; // adjust if your controller package differs
import com.cox.oss.prov.pal.common.proxy.PalHttpProxyService; // adjust if service is in a different package
import com.cox.oss.prov.pal.common.proxy.model.PalForwardHttpRequest; // adjust to actual package
import com.cox.oss.prov.pal.common.model.PalMapModel; // adjust to actual package

@ExtendWith(MockitoExtension.class)
class PalCmiProxyRestControllerTest {

    // ---------- Test: happy path with body ----------
    @Test
    void handleAllRequests_withBody_forwardsAndReturnsServiceResponse() {
        // Arrange
        PalCmiProxyRestController controller = new PalCmiProxyRestController(null); // PalProxyService not used, pass null or mock if needed

        Map<String, String> pathVariables = new HashMap<>();
        pathVariables.put("appCode", "TEST_APP");

        PalMapModel body = mock(PalMapModel.class);

        Map<String, Object> requestParams = new HashMap<>();
        requestParams.put("q", "v");

        HttpServletRequest request = mock(HttpServletRequest.class);
        when(request.getMethod()).thenReturn("POST");
        when(request.getRequestURI()).thenReturn("/proxy/v1/app/TEST_APP/some/path");

        ResponseEntity<Object> fakeResponse = ResponseEntity.ok("OK-FORWARDED");

        // Intercept construction of PalHttpProxyService and stub execute(...) on the constructed instance
        try (MockedConstruction<PalHttpProxyService> mocked = mockConstruction(PalHttpProxyService.class,
                (mock, context) -> {
                    when(mock.execute(any(PalForwardHttpRequest.class))).thenReturn(fakeResponse);
                })) {

            // Act
            ResponseEntity<Object> actual = controller.handleAllRequests(pathVariables, body, requestParams, request);

            // Assert response is what the service returned
            assertNotNull(actual);
            assertEquals(fakeResponse, actual);

            // Verify a PalHttpProxyService was constructed exactly once
            List<PalHttpProxyService> constructed = mocked.constructed();
            assertEquals(1, constructed.size(), "PalHttpProxyService should be constructed exactly once");

            // Verify execute(...) was invoked with a PalForwardHttpRequest and inspect it
            PalHttpProxyService serviceInstance = constructed.get(0);
            ArgumentCaptor<PalForwardHttpRequest> captor = ArgumentCaptor.forClass(PalForwardHttpRequest.class);
            verify(serviceInstance, times(1)).execute(captor.capture());
            PalForwardHttpRequest forwarded = captor.getValue();
            assertNotNull(forwarded, "forwarded PalForwardHttpRequest should not be null");
            assertEquals("TEST_APP", forwarded.getAppCode(), "appCode should be set on the forward request");
            assertSame(body, forwarded.getBody(), "request body should be forwarded unchanged");
            assertNotNull(forwarded.getUri(), "uri should not be null");
        }
    }

    // ---------- Test: happy path without body ----------
    @Test
    void handleAllRequests_withoutBody_forwardsAndReturnsServiceResponse() {
        // Arrange
        PalCmiProxyRestController controller = new PalCmiProxyRestController(null);

        Map<String, String> pathVariables = new HashMap<>();
        pathVariables.put("appCode", "NO_BODY_APP");

        PalMapModel body = null;

        Map<String, Object> requestParams = new HashMap<>();

        HttpServletRequest request = mock(HttpServletRequest.class);
        when(request.getMethod()).thenReturn("PUT");
        when(request.getRequestURI()).thenReturn("/proxy/v1/app/NO_BODY_APP/");

        ResponseEntity<Object> fakeResponse = ResponseEntity.ok("OK-NOBODY");

        try (MockedConstruction<PalHttpProxyService> mocked = mockConstruction(PalHttpProxyService.class,
                (mock, context) -> {
                    when(mock.execute(any(PalForwardHttpRequest.class))).thenReturn(fakeResponse);
                })) {

            // Act
            ResponseEntity<Object> actual = controller.handleAllRequests(pathVariables, body, requestParams, request);

            // Assert
            assertNotNull(actual);
            assertEquals(fakeResponse, actual);

            // Verify service constructed & execute called
            List<PalHttpProxyService> constructed = mocked.constructed();
            assertEquals(1, constructed.size());
            PalHttpProxyService serviceInstance = constructed.get(0);
            ArgumentCaptor<PalForwardHttpRequest> captor = ArgumentCaptor.forClass(PalForwardHttpRequest.class);
            verify(serviceInstance).execute(captor.capture());
            PalForwardHttpRequest forwarded = captor.getValue();
            assertEquals("NO_BODY_APP", forwarded.getAppCode());
            assertNull(forwarded.getBody(), "expected null body to be forwarded when client provided no body");
        }
    }

    // ---------- Test: service throws exception (propagate) ----------
    @Test
    void handleAllRequests_whenServiceThrows_propagatesException() {
        // Arrange
        PalCmiProxyRestController controller = new PalCmiProxyRestController(null);

        Map<String, String> pathVariables = new HashMap<>();
        pathVariables.put("appCode", "ERR_APP");

        PalMapModel body = mock(PalMapModel.class);
        Map<String, Object> requestParams = new HashMap<>();

        HttpServletRequest request = mock(HttpServletRequest.class);
        when(request.getMethod()).thenReturn("PATCH");
        when(request.getRequestURI()).thenReturn("/proxy/v1/app/ERR_APP/err");

        RuntimeException ex = new RuntimeException("execute-failed");

        try (MockedConstruction<PalHttpProxyService> mocked = mockConstruction(PalHttpProxyService.class,
                (mock, context) -> {
                    when(mock.execute(any(PalForwardHttpRequest.class))).thenThrow(ex);
                })) {

            // Act & Assert
            RuntimeException thrown = assertThrows(RuntimeException.class,
                    () -> controller.handleAllRequests(pathVariables, body, requestParams, request));
            assertSame(ex, thrown);

            // verify execute was called
            List<PalHttpProxyService> constructed = mocked.constructed();
            assertEquals(1, constructed.size());
            PalHttpProxyService serviceInstance = constructed.get(0);
            verify(serviceInstance).execute(any(PalForwardHttpRequest.class));
        }
    }
}
