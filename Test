package your.package.name; // change to your package

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedConstruction;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.ResponseEntity;

import java.util.Collections;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

/**
 * Tests for PalServiceDevRestController.service(...)
 */
@ExtendWith(MockitoExtension.class)
class PalServiceDevRestControllerTest {

    private final PalServiceDevRestController controller = new PalServiceDevRestController();

    /**
     * Verifies that controller calls the mapping, constructs PalServiceRequest and returns the ResponseEntity
     * provided by PalServiceRequest.execute4api().
     */
    @Test
    void service_callsMapping_and_returnsResponse() {
        // Arrange
        String apiName = "myApi";
        PalMapModel input = new PalMapModel();
        Map<String, String> headers = Collections.emptyMap();

        // Prepare a dummy mapped model (controller will pass this as the request to PalServiceRequest ctor)
        Object mappedModel = new PalMapModel(); // could be any object expected by PalServiceRequest

        // Prepare expected ResponseEntity returned from execute4api()
        @SuppressWarnings("unchecked")
        PalServiceResponse<String> responseBody = mock(PalServiceResponse.class);
        ResponseEntity<PalServiceResponse<String>> expectedResponse = ResponseEntity.ok(responseBody);

        // Mock static PalServiceModelMapping.getModel(apiName, input) to return mappedModel
        try (MockedStatic<PalServiceModelMapping> mappingMock = mockStatic(PalServiceModelMapping.class)) {
            mappingMock.when(() -> PalServiceModelMapping.getModel(eq(apiName), eq(input))).thenReturn(mappedModel);

            // Intercept construction of PalServiceRequest and stub execute4api() to return expectedResponse
            try (MockedConstruction<PalServiceRequest> mockedConstruction =
                         mockConstruction(PalServiceRequest.class, (mock, context) -> {
                             when(mock.execute4api()).thenReturn(expectedResponse);
                         })) {

                // Act
                ResponseEntity<PalServiceResponse<String>> actual = controller.service(headers, apiName, input);

                // Assert - response forwarded from mocked execute4api()
                assertNotNull(actual, "Controller should return a ResponseEntity");
                assertSame(expectedResponse, actual, "Controller should return the ResponseEntity from PalServiceRequest.execute4api()");

                // Verify static mapping was called
                mappingMock.verify(() -> PalServiceModelMapping.getModel(eq(apiName), eq(input)), times(1));

                // Verify a PalServiceRequest was constructed exactly once
                assertEquals(1, mockedConstruction.constructed().size(), "Exactly one PalServiceRequest should be constructed");

                // Verify execute4api was called on the constructed instance
                PalServiceRequest constructedMock = mockedConstruction.constructed().get(0);
                verify(constructedMock, times(1)).execute4api();
            }
        }
    }

    /**
     * Verifies that if execute4api() throws an exception the controller does not swallow it (propagates).
     */
    @Test
    void service_whenExecuteThrows_exceptionPropagates() {
        // Arrange
        String apiName = "myApi";
        PalMapModel input = new PalMapModel();
        Map<String, String> headers = Collections.emptyMap();

        Object mappedModel = new PalMapModel();

        try (MockedStatic<PalServiceModelMapping> mappingMock = mockStatic(PalServiceModelMapping.class)) {
            mappingMock.when(() -> PalServiceModelMapping.getModel(eq(apiName), eq(input))).thenReturn(mappedModel);

            RuntimeException boom = new RuntimeException("execute failed");

            try (MockedConstruction<PalServiceRequest> mockedConstruction =
                         mockConstruction(PalServiceRequest.class, (mock, context) -> {
                             when(mock.execute4api()).thenThrow(boom);
                         })) {

                // Act & Assert - expect the same exception to propagate
                RuntimeException thrown = assertThrows(RuntimeException.class,
                        () -> controller.service(headers, apiName, input));
                assertSame(boom, thrown, "The exception thrown by execute4api() should propagate");

                // verify mapping and construction happened
                mappingMock.verify(() -> PalServiceModelMapping.getModel(eq(apiName), eq(input)), times(1));
                assertEquals(1, mockedConstruction.constructed().size());
                PalServiceRequest constructedMock = mockedConstruction.constructed().get(0);
                verify(constructedMock, times(1)).execute4api();
            }
        }
    }
}
